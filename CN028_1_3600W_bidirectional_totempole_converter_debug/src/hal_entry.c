#include "hal_data.h"
#include "ra6t2.h"
#include "console.h"
#include "user_define.h"
#include "ntc.h"
#include "can_fd.h"
#include "digitPow.h"
#include <math.h>

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

void heart_beat(void);
void key_scan(void);
static uint32_t hb_cntr = 0;
uint32_t key_cntr = 0;

static int32_t Iac_adc_offset = 0;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
	PORT_OUTPUT_FAN = 1;

    hardware_init();
    dp_para_init();
    serial_para_init();

    startup();

    while (1)
    {
        uart_operation();
        canfd_operation();
        dp_routine();
        key_scan();
        heart_beat();
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif

void g_adc_b_callback(adc_callback_args_t *p_args)
{
    if(NULL != p_args)
    {
        if (ADC_EVENT_SCAN_COMPLETE  == p_args->event)
        {
            if (ADC_GROUP_MASK_0 == p_args->group_mask)
            {
                err = g_adc0.p_api->read32(&g_adc0_ctrl, ADC_CHANNEL_0, &g_para.Vac_adc_raw);
                err = g_adc0.p_api->read32(&g_adc0_ctrl, ADC_CHANNEL_1, &g_para.Iac_adc_raw);
                err = g_adc0.p_api->read32(&g_adc0_ctrl, ADC_CHANNEL_2, &g_para.Vdc_adc_raw);

                g_para.Iac_adc_raw = (uint32_t)((int32_t)g_para.Iac_adc_raw - Iac_adc_offset);

                g_para.Vac_adc_vol = (float)g_para.Vac_adc_raw * 0.00080586;		//0.00080586=3.3/4095;
                g_para.Vac_adc = 311*(g_para.Vac_adc_vol - 1.65);
                g_para.Iac_adc_vol = (float)g_para.Iac_adc_raw * 0.00080586;
                g_para.Iac_adc = (g_para.Iac_adc_vol - 1.61211529) * 31.015151515;	//1.61211529=1.65*2/2.047; 31.015151515=1/0.033*2.047/2;
                g_para.Vdc_adc_vol = (float)g_para.Vdc_adc_raw * 0.00080586;
                g_para.Vdc_adc = 157.67*g_para.Vdc_adc_vol;

                g_para.Vac_adc = 0.952 * g_para.Vac_adc + 0.048 * g_para.Vac_adc_old;
                g_para.Vac_adc_old = g_para.Vac_adc;
                g_para.Vdc_adc = 0.952 * g_para.Vdc_adc + 0.048 * g_para.Vdc_adc_old;
                g_para.Vdc_adc_old = g_para.Vdc_adc;

                fast_protection();

                if (g_sys.state == RUN_STATE)
                {
                	task_66kHz();
                }
            }
            if (ADC_GROUP_MASK_1 == p_args->group_mask)
            {
                err = g_adc0.p_api->read32(&g_adc0_ctrl, ADC_CHANNEL_3, &g_para.Temp_adc_raw);
                g_para.Temp_adc_raw = g_para.Temp_adc_raw & 0x7fffffff;
                g_para.Temp_adc = ntc_table[(uint16_t)((g_para.Temp_adc_raw - 900) / 10)];

                slow_protection();

                if (g_sys.state == RUN_STATE)
                {
                	task_10kHz();
                }
            }
        }
    }

}

extern bool gf_kint4_enable;
extern uint16_t kint4_time;
void g_agt1_10kHz_callback(timer_callback_args_t *p_args)
{
    static uint16_t cont;
    static float Iac_sum, Pac_sum, Vac_sum;
    static float Fac;
    float fre_err;
    static uint16_t state_cont = 0;
    static uint8_t AC_level;

    static bool zero_offset_en = false, zero_offset_start = false, zero_offset_cal = true;
    static uint8_t adc_cont = 0;
    static uint32_t adc_sum0 = 0;

    UNUSED(p_args);
    if (g_sys.app != APP_OFF_GRID_INVERTER)
    {
    	if (R_ACMPHS0->CMPMON_b.CMPMON == 0)
        {
            if (AC_level == 1)
            {
                Fac = 1 / (cont * Ts);
                g_para.monitor_Iac_rms = (float)sqrt(Iac_sum / cont);
                g_para.monitor_Pac = Pac_sum / cont;

                Iac_sum = 0;
                Pac_sum = 0;
                cont = 0;
                AC_level = 0;
            }
        }
        else
        {
        	if (AC_level == 0)
        	{
        		g_sys.cross_zero = 1;	//正向过零
        		AC_level = 1;

        	}
        	else
        	{
        		g_sys.cross_zero = 0;
        	}
        }
        cont++;
        Iac_sum += g_para.Iac_adc * g_para.Iac_adc;
        Pac_sum += -1 * g_para.Iac_adc * g_para.Vac_adc;

    	if (g_sys.state == PLL_SYNC_STATE)
    	{
    		g_sogi.Xn = g_para.Vac_adc;
    		PLL(Ts, &g_sogi, &g_pll_pi, g_para.Fac_tgt, &g_para.Theta, &g_para.monitor_Vac_rms, &g_para.monitor_Fac);

        	state_cont++;
            if (state_cont >= 10000)//1s
            {
            	state_cont = 0;
                fre_err = g_para.monitor_Fac > Fac ? (g_para.monitor_Fac - Fac) : (Fac - g_para.monitor_Fac);

                if (g_sys.app == APP_GRID_CONNECTED_INVERTER)
                {
                    float vdc_min = g_para.monitor_Vac_rms * 1.414 * 0.7;
                    float vdc_max = g_para.monitor_Vac_rms * 1.414 * 1.3;
                    if (g_para.Vdc_adc > vdc_max)
                    {
                    	g_sys.err.bit.VDC_OVP = 1;
                    	return;
                    }
                    else if (g_para.Vdc_adc < vdc_min)
                    {
                    	g_sys.err.bit.VDC_UVP = 1;
                    	return;
                    }
                }

                if ((fre_err / g_para.monitor_Fac) > ERR_PLL_RATE)
                {
                	g_sys.err.bit.PLL_ERR = 1;
                }
                else
                {
                	g_para.Fac_tgt = g_para.monitor_Fac < 55 ? 50 : 60;
                	if (g_para.monitor_Vac_rms < 165)
                	{
                		g_para.TH_Vac_rms_Min = 85;
                		g_para.TH_Vac_rms_Max = 130;
                	}
                	else
                	{
                		g_para.TH_Vac_rms_Min = 170;
                		g_para.TH_Vac_rms_Max = 260;
                	}

                    notch_flt_para_init(2*M_PI*g_para.Fac_tgt*2, 2*M_PI*30, &notchflt_for_vdc);

					g_sys.state = WAIT_TO_RUN_STATE;
                    PORT_OUTPUT_RELAY = 1;
                }
            }
    	}
    	else if (g_sys.state == WAIT_TO_RUN_STATE)
        {
    		g_sogi.Xn = g_para.Vac_adc;
        	PLL(Ts, &g_sogi, &g_pll_pi, g_para.Fac_tgt, &g_para.Theta, &g_para.monitor_Vac_rms, &g_para.monitor_Fac);
        	state_cont++;

            notchflt_for_vdc.Xn = g_para.Vdc_adc;
            g_para.Vdc_flt = iir_filter(&notchflt_for_vdc);
            if (state_cont >= 5000)//40ms->0.5s
            {
            	if (g_sys.cross_zero == 1)
            	{
            		g_sys.state = RUN_STATE;
            		state_cont = 0;
            	}
            }
        }
    }
    else
    {
    	if (g_para.Theta_ref < M_PI)
    	{
            if (AC_level == 1)
            {
            	g_para.monitor_Iac_rms = (float)sqrt(Iac_sum / cont);
            	g_para.monitor_Vac_rms = (float)sqrt(Vac_sum / cont);
            	g_para.monitor_Pac = Pac_sum / cont;

                Iac_sum = 0;
                Pac_sum = 0;
                Vac_sum = 0;
                cont = 0;
                AC_level = 0;
            }
    	}
    	else
    	{
        	if (AC_level == 0)
        	{
        		g_sys.cross_zero = 1;	//正向过零
        		AC_level = 1;
        	}
        	else
        	{
        		g_sys.cross_zero = 0;
        	}
    	}
        cont++;
        Iac_sum += g_para.Iac_adc * g_para.Iac_adc;
        Pac_sum += g_para.Iac_adc * g_para.Vac_adc;
        Vac_sum += g_para.Vac_adc * g_para.Vac_adc;

    	if (g_sys.state == PLL_SYNC_STATE)
    	{
    		g_sys.state = WAIT_TO_RUN_STATE;
            PORT_OUTPUT_RELAY = 1;
    	}
    	else if (g_sys.state == WAIT_TO_RUN_STATE)
    	{
        	state_cont++;
        	if (state_cont >= 5000)
        	{
        		g_sys.state = RUN_STATE;
            	state_cont = 0;
        	}
    	}
    }

    //IAC零偏计算
    if (zero_offset_cal)
    {
        if (g_sys.cross_zero == 0)
        {
        	zero_offset_en = true;
        }
        if (g_sys.cross_zero == 1 && zero_offset_start== true)
        {
        	zero_offset_start = false;
        	zero_offset_cal = false;
        }
        else if (g_sys.cross_zero == 1 && zero_offset_en == true)
        {
        	zero_offset_start = true;
        }
        if (zero_offset_start)
        {
            adc_sum0 += g_para.Iac_adc_raw;
            adc_cont++;
        }
        else if (zero_offset_cal == false)
        {
        	Iac_adc_offset = (int32_t)((int32_t)(adc_sum0 / adc_cont) - 2000);
            if (Iac_adc_offset > 123 || Iac_adc_offset < -123)
            {
                g_sys.err.bit.INNER_ERR = 1;
                Iac_adc_offset = 0;
            }
        }
    }

    hb_cntr++;
    key_cntr++;
    if (con.f.uart_connect)	con.f.uart_rx_timeout++;
    if (con.f.can_connect)
    {
    	con.f.can_tx_time++;
    	if (con.f.can_tx_time >= 1000)
    	{
    		con.f.can_tx_time = 0;
    		con.f.can_tx_en = true;
    	}
    }
    if (gf_kint4_enable == false)
    {
    	kint4_time++;
    }
}

void heart_beat(void)
{
    switch (g_sys.state)
    {
    	case FAULT_STATE:
            if (hb_cntr >= 10000)
            {
            	hb_cntr = 0;
            	LED_HEARTBEAT ^= 1;
            }
    		break;
    	case STANDBY_STATE:
            if (hb_cntr >= 20000)
            {
            	hb_cntr = 0;
            	LED_HEARTBEAT ^= 1;
            }
    		break;
    	default:
            if (hb_cntr >= 30000)
            {
            	hb_cntr = 0;
            	LED_HEARTBEAT ^= 1;
            }
    		break;
    }
}

uint16_t press_cont[2];
bool f_key_released = true;
void key_scan(void)
{
	if (key_cntr >= 10)
	{
		key_cntr = 0;
		if (KEY_ENB == 0)
		{
			press_cont[0]++;
			if (press_cont[0] > 200 && f_key_released == true)
			{
				g_kint_signal = CH_MASK_4;
				f_key_released = false;
			}
		}
		else if (KEY_RST == 0)
		{
			press_cont[1]++;
			if (press_cont[1] > 200 && f_key_released == true)
			{
				g_kint_signal = CH_MASK_5;
				f_key_released = false;
			}
		}
		else
		{
			press_cont[0] = 0;
			press_cont[1] = 0;
			f_key_released = true;
		}
	}
}
